# 7.0权限申请

# 系统权限更改

> 目录权限

为了提高私有文件的安全性，面向 Android 7.0 或更高版本的应用私有目录被限制访问　(0700)。此设置可防止私有文件的元数据泄漏，如它们的大小或存在性。此权限更改有多重副作用：

私有文件的文件权限不应再由所有者放宽，为使用 **MODE_WORLD_READABLE** 和或 **MODE_WORLD_WRITEABLE** 而进行的此类尝试将触发 **SecurityException**。

- 注：迄今为止，这种限制尚不能完全执行。应用仍可能使用原生 API 或 File API 来修改它们的私有目录权限。但是，我们强烈反对放宽私有目录的权限。

------

# 文件权限更改

> FileUriExposedException 异常

传递软件包网域外的 **file:// URI** 可能给接收器留下无法访问的路径。

因此，尝试传递 file:// URI 会触发 FileUriExposedException。分享私有文件内容的推荐方法是使用 FileProvider。

**DownloadManager** 不再按文件名分享私人存储的文件。旧版应用在访问 COLUMN_LOCAL_FILENAME 时可能出现无法访问的路径。

面向 Android 7.0 或更高版本的应用在尝试访问 **COLUMN_LOCAL_FILENAME** 时会触发 SecurityException。

通过使用 

通过使用 
 `DownloadManager.Request.setDestinationInExternalFilesDir()`  

通过使用 
 `DownloadManager.Request.setDestinationInExternalFilesDir()`  
 或者 

通过使用 
 `DownloadManager.Request.setDestinationInExternalFilesDir()`  
 或者 
`DownloadManager.Request.setDestinationInExternalPublicDir()` 

将下载位置设置为**公共位置**的旧版应用仍可以访问 COLUMN_LOCAL_FILENAME 中的路径，但是我们强烈反对使用这种方法。

对于由 **DownloadManager** 公开的文件，首选的访问方式是使用`ContentResolver.openFileDescriptor()`

> 在应用间共享文件  StrictMode API

对于面向 Android 7.0 的应用，Android 框架执行的 **StrictMode API** 政策禁止在您的应用外部公开 file:// URI。

如果一项包含文件 URI 的 intent 离开您的应用，则应用出现故障，并出现 FileUriExposedException 异常。

要在应用间共享文件，您应发送一项 content:// URI，并授予 URI 临时访问权限。

进行此授权的最简单方式是使用 **FileProvider** 类。如需了解有关权限和共享文件的详细信息，请谷歌开发中的[《共享文件权限操作方法》](https://developer.android.google.cn/training/secure-file-sharing/index.html)

- [设置文件共享](https://developer.android.google.cn/training/secure-file-sharing/setup-sharing.html) 

    了解如何设置您的应用程序共享文件。

- [共享文件](https://developer.android.google.cn/training/secure-file-sharing/share-file.html) 

    了解如何通过生成文件的内容URI，向URI授予访问权限，并向应用程序发送URI，从而向另一个应用程序提供文件。

- [请求共享文件](https://developer.android.google.cn/training/secure-file-sharing/request-file.html) 

    了解如何请求另一个应用程序共享的文件，接收该文件的内容URI，并使用内容URI打开文件。

- [获取文件信息](https://developer.android.google.cn/training/secure-file-sharing/retrieve-info.html) 

    学习如何应用程序可以使用由fileprovider检索包括MIME类型和文件大小，文件信息生成的内容URI。

------

# FileProvider

FileProvider，是Android 7.0新增的一个类，该类位于v4包下的android.support.v4.content.FileProvider，使用方法和ContentProvider类似，操作步骤如下：

**一、在资源文件夹res/xml下新建file_provider.xml文件，文件声明权限请求的路径，代码如下：**

```
    <?xml version="1.0" encoding="utf-8"?>
    <paths xmlns:android="http://schemas.android.com/apk/res/android">
        <!--对应外部内存卡根目录：Environment.getExternalStorageDirectory()-->
          <external-path name="ext_root" path="/" />
        <!--指定文件存储的区块和区块的相对路径-->
         <files-path name="my_path" path="images/"/>
    </paths>1234567
```

**属性说明：**

指定文件存储的区块和区块的相对路径 

- `name`：是一个虚设的文件名（可以自由命名），对外可见路径的一部分，隐藏真实文件目录
- `path`：是一个相对目录，相对于当前的子标签根目录，：表示内部内存卡根目录，对应根目录等价于Context.getFilesDir()，完整路径：`/data/use/mnt/sdcard/com.immqy.dujinyang/files`

这里的path要对应上相关路径，这里是想根目录，不指定特别目录，所以直接用`"/"`即可。

`<paths>`根标签下可以添加的子标签也是有限的，除了上述的提到的这个子标签外，还包括下面几个：

1. `<cache-path>`，表示应用默认缓存根目录，对应根目录等价于getCacheDir()，查看完整路径：/data/user/0/cn.teachcourse.demos/cache

2. `<external-path>`，表示外部内存卡根目录，对应根目录等价于 

   Environment.getExternalStorageDirectory()， 路径：/storage/emulated/0

3. `<external-files-path>`，表示外部内存卡根目录下的APP公共目录，对应根目录等价于 

   Context的getExternalFilesDir(String) ， 路径： 

   /storage/emulated/0/Android/data/com.immqy.www

4. `<external-cache-path>`，表示外部内存卡根目录下的APP缓存目录，对应根目录等价于Context.getExternalCacheDir()，路径： 

   /storage/emulated/0/Android/data/cn.teachcourse.demos/cache



示例： 
最终，在file_provider.xml文件中，添加上述5种类型的临时访问权限的文件目录，代码如下：

```
<?xml version="1.0" encoding="utf-8"?>
<paths xmlns:android="http://schemas.android.com/apk/res/android">
    <!--
    1、name对应的属性值，开发者可以自由定义；
    2、path对应的属性值，当前external-path标签下的相对路径
    比如：/storage/emulated/0/92Recycle-release.apk
    sdcard路径：/storage/emulated/0(WriteToReadActivity.java:176)
                      at cn.teachcourse.nougat.WriteToReadActivity.onClick(WriteToReadActivity.java:97)
                      at android.view.View.performClick(View.java:5610)
                      at android.view.View$PerformClick.run(View.java:22265)
    相对路径：/
    -->
    <!--1、对应内部内存卡根目录：Context.getFileDir()-->
    <files-path
        name="int_root"
        path="/" />
    <!--2、对应应用默认缓存根目录：Context.getCacheDir()-->
    <cache-path
        name="app_cache"
        path="/" />
    <!--3、对应外部内存卡根目录：Environment.getExternalStorageDirectory()-->
    <external-path
        name="ext_root"
        path="pictures/" />
    <!--4、对应外部内存卡根目录下的APP公共目录：Context.getExternalFileDir(String)-->
    <external-files-path
        name="ext_pub"
        path="/" />
    <!--5、对应外部内存卡根目录下的APP缓存目录：Context.getExternalCacheDir()-->
    <external-cache-path
        name="ext_cache"
        path="/" />
</paths>123456789101112131415161718192021222324252627282930313233
```

所以生成指定文件的Content URI的步骤：

- 确定上述用哪一种 （5种类型）
- 明确指定文件的完整路径（包括目录、文件名）
- 调用getUriForFile()方法生成 

除了普通的授权，还有一种是Intent发送对外授权，对外提供可访问的Content URI，在重写的startActivityResult()方法中获取授予临时权限的Content URI或向用户提供可访问的接口来获取文件，后面的这种方式获取文件后转换成Content URI。

- 请求授予访问公共目录的权限，代码如下

```
 if (Build.VERSION.SDK_INT > 23) {
        /**Android 7.0以上的方式**/
        mStorageManager = this.getSystemService(StorageManager.class);
        StorageVolume storageVolume = mStorageManager.getPrimaryStorageVolume();
        Intent intent = storageVolume.createAccessIntent(Environment.DIRECTORY_PICTURES);
        startActivityForResult(intent, REQUEST_DCODE_GRAINT_URI);
    }1234567
```

- 重写的startActivityResult()方法中获取授予临时权限的Content URI，代码如下：

```
   @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        switch (requestCode) {
            case REQUEST_DCODE_GRAINT_URI:
                updateDirectoryEntries(data.getData());
                Log.d(TAG, "onActivityResult:Uri= "+data.getData());
                break;

        }
    }1234567891011
```

- 查询Environment.DIRECTORY_PICTURES目录，返回的Content URI包含的文件和文件类型相关信息，代码如下：

```
private static final String[] DIRECTORY_SELECTION = new String[]{
            DocumentsContract.Document.COLUMN_DISPLAY_NAME,
            DocumentsContract.Document.COLUMN_MIME_TYPE,
            DocumentsContract.Document.COLUMN_DOCUMENT_ID,
    };
    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
    private void updateDirectoryEntries(Uri uri) {
        ContentResolver contentResolver = this.getContentResolver();
        Uri docUri = DocumentsContract.buildDocumentUriUsingTree(uri,
                DocumentsContract.getTreeDocumentId(uri));
        Uri childrenUri = DocumentsContract.buildChildDocumentsUriUsingTree(uri,
                DocumentsContract.getTreeDocumentId(uri));

        try (Cursor docCursor = contentResolver
                .query(docUri, DIRECTORY_SELECTION, null, null, null)) {
            while (docCursor != null && docCursor.moveToNext()) {
                mPath_tv.setText(docCursor.getString(docCursor.getColumnIndex(
                        DocumentsContract.Document.COLUMN_DISPLAY_NAME)));
            }
        }

        try (Cursor childCursor = contentResolver
                .query(childrenUri, DIRECTORY_SELECTION, null, null, null)) {
            while (childCursor != null && childCursor.moveToNext()) {
                String fileName = childCursor.getString(childCursor.getColumnIndex(
                        DocumentsContract.Document.COLUMN_DISPLAY_NAME));
                String mimeType = childCursor.getString(childCursor.getColumnIndex(
                        DocumentsContract.Document.COLUMN_MIME_TYPE));
                Log.e(TAG, "Directory: "+fileName+"\n"+mimeType);
            }

        }
    }123456789101112131415161718192021222324252627282930313233
```

生成Content URI的临时授权： 

生成Content URI的临时授权： 
上一步并没有获得指定文件的读写权限，想要获得文件的读写权限需要调用Context.grantUriPermission(package, Uri, mode_flags)方法，该方法向指定包名的应用程序申请获得读取或者写入文件的权限，参数说明如下：

- `package`：指定应用程序的包名，Android Studio真正的包名指build.gradle声明的applicationId属性值；`getPackageName()`：指AndroidManifest.xml文件声明的package属性值，如果两者不一致，就不能提供getPackageName()获取包名，否则报错！

- `Uri`：指定请求授予临时权限的URI，例如：contentUri

- `mode_flags`：指定授予临时权限的类型，选择其中一个常量或两个：Intent.FLAG_GRANT_READ_URI_PERMISSION，Intent.FLAG_GRANT_WRITE_URI_PERMISSION 

  `mode_flags`：指定授予临时权限的类型，选择其中一个常量或两个：Intent.FLAG_GRANT_READ_URI_PERMISSION，Intent.FLAG_GRANT_WRITE_URI_PERMISSION 
  授予文件的临时读取或写入权限，如果不再需要了，TeachCourse该如何撤销授予呢？撤销权限有两种方式：第一种：通过调用revokeUriPermission()撤销，第二种：重启系统后自动撤销

```
File imagePath = new File(Environment.getExternalStorageDirectory(), "download");
File newFile = new File(imagePath, "miqiyun_image.jpg");
Uri contentUri = getUriForFile(getContext(), "com.immqy.karl-dujinyang", newFile); 123
```

**二、AndroidManifest.xml 添加组件 provider 相关信息，类似组件 activity ，指定resource属性引用上一步创建的xml文件（后面会详细介绍各个属性的用法），代码如下：**

```
   <!-- 定义FileProvider -->
    <provider
        android:name="android.support.v4.content.FileProvider"
        android:authorities="@string/pack_name"
        android:exported="false"
        android:grantUriPermissions="true">
        <meta-data
            android:name="android.support.FILE_PROVIDER_PATHS"
            android:resource="@xml/file_provider" />
    </provider>12345678910
```

**属性说明：**

- `android:name`：对应属性值：android.support.v4.content.FileProvider或者子类完整路径

- `android:authorities`：对应属性值是一个常量，通常定义的方式packagename.fileprovider，如：com.immqy.dujinyang.fileprovider

- `android:exported`：对应属性值是一个boolean变量，设置为false 

- `android:grantUriPermissions`：对应属性值也是一个boolean变量，设置为true，允许获得文件临时的访问权限

  关联res/xml文件夹下创建的file_provider.xml文件，需要在标签内，添加子标签，设置标签的属性值，包括：

- 标签 `android:name`：对应属性值是一个固定的系统常量`android.support.FILE_PROVIDER_PATHS`

- 标签 `android:resource`：对应属性值指向我们的xml文件 `@xml/file_provider`

**三、代码上做动态权限申请，使用getUriForFile()和grantUriPermission()，代码如下：**

```
 if (Build.VERSION.SDK_INT > 23) {
        /**Android 7.0以上的方式**/
        Uri contentUri = getUriForFile(this, getString(R.string.pack_name), file);
        grantUriPermission(getPackageName(), contentUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
        intent.putExtra(MediaStore.EXTRA_OUTPUT, contentUri);
    } 123456
```

注意：申请的是`FLAG_GRANT_WRITE_URI_PERMISSION`

测试：修改build.gradle文件compileSdkVersion大于或等于24，targetSdkVersion等于24，然后使用Android 7.0模拟器运行Demo，完成无误。

