# 序列化的三种实现

Android中，Activity和Fragment之间传递对象，可以通过将对象序列化并存入Bundle或者Intent中进行传递，也可以将对象转化为JSON字符串，进行传递。

序列化对象可以使用Java的Serializable的接口、Parcelable接口。转化成JSON字符串，可以使用Gson等库。

**1.Serializable**

```java
public class Author implements Serializable{ 
  private int id; 
  
  private String name; 
  
  //... 
}


public class Book implements Serializable{ 
  private String title; 
  private Author author; 
  //... 
}
```

**传递数据**

```java
Book book=new Book();  
book.setTitle("Java编程思想");  
Author author=new Author();  
author.setId(1);  
author.setName("Bruce Eckel");  
book.setAuthor(author);  
Intent intent=new Intent(this,SecondActivity.class);  
intent.putExtra("book",book);  
startActivity(intent);
```

**接收数据**

```java
Book book= (Book) getIntent().getSerializableExtra("book"); 
Log.d(TAG,"book title->"+book.getTitle()); 
Log.d(TAG,"book author name->"+book.getAuthor().getName());
```

**2.转化为JSON字符串**

```java
public class Author{ 
  private int id; 
  
  private String name; 
  
  //... 
} 

public class Book{ 
  private String title; 
  private Author author; 
  //... 
} 
```

**传递数据**

```java
Book book=new Book(); 
book.setTitle("Java编程思想"); 
Author author=new Author(); 
author.setId(1); 
author.setName("Bruce Eckel"); 
book.setAuthor(author); 
Intent intent=new Intent(this,SecondActivity.class); 
intent.putExtra("book",new Gson().toJson(book)); 
startActivity(intent); 
```

**接收数据**

```java
String bookJson=getIntent().getStringExtra("book"); 
Book book=new Gson().fromJson(bookJson,Book.class); 
Log.d(TAG,"book title->"+book.getTitle()); 
Log.d(TAG,"book author name->"+book.getAuthor().getName());1 1
```

**3.使用Parcelable**

实现Parcelable接口需要实现两个方法

- describeContents方法。内容接口描述，默认返回0就可以;
- writeToParcel方法。将传递的数据打包到Parcel容器中。

除了要实现这两个方法还必须创建一个Parcelable.Creator接口的实例，用于读取Parcel容器中的数据

```java
public class Author implements Parcelable{ 
  private int id; 
  
  private String name; 
  
  //setter & getter... 
  
  @Override
  public int describeContents() { 
  
    return 0; 
  } 
  
  @Override
  public void writeToParcel(Parcel dest, int flags) { 
    //该方法将类的数据写入外部提供的Parcel中.即打包需要传递的数据到Parcel容器保存， 
    // 以便从parcel容器获取数据 
    dest.writeString(name); 
    dest.writeInt(id); 
  
  } 
  public static final Creator<Author> CREATOR=new Creator<Author>() { 
    @Override
    public Author createFromParcel(Parcel source) { 
      //从Parcel容器中读取传递数据值，封装成Parcelable对象返回逻辑层。 
      Author author=new Author(); 
      author.setName(source.readString()); 
      author.setId(source.readInt()); 
      return author; 
    } 
  
    @Override
    public Author[] newArray(int size) { 
      //创建一个类型为T，长度为size的数组，仅一句话（return new T[size])即可。方法是供外部类反序列化本类数组使用。 
      return new Author[size]; 
    } 
  }; 
} 
```

```java
public class Book implements Parcelable{ 
  private String title; 
  private Author author; 
  //setter & getter... 
  
  @Override
  public int describeContents() { 
    return 0; 
  } 
  
  @Override
  public void writeToParcel(Parcel dest, int flags) { 
    dest.writeString(title); 
    dest.writeParcelable(author,flags); 
  } 
  public static final Creator<Book> CREATOR=new Creator<Book>() { 
    @Override
    public Book createFromParcel(Parcel source) { 
      Book book=new Book(); 
      book.setTitle(source.readString()); 
      book.setAuthor(source.<Author>readParcelable(Author.class.getClassLoader())); 
      return book; 
    } 
  
    @Override
    public Book[] newArray(int size) { 
      return new Book[0]; 
    } 
  }; 
} 
```

**传递数据**

```java
Book book=new Book(); 
book.setTitle("Java编程思想"); 
Author author=new Author(); 
author.setId(1); 
author.setName("Bruce Eckel"); 
book.setAuthor(author); 
Intent intent=new Intent(this,SecondActivity.class); 
intent.putExtra("book",book); 
startActivity(intent); 
```

**接收数据**

```java
Book book=getIntent().getParcelableExtra("book"); 
Log.d(TAG,"book title->"+book.getTitle()); 
Log.d(TAG,"book author name->"+book.getAuthor().getName()); 
```

**4.性能分析**

经过测试，我们得到下图的效果

 ![](http://files.jb51.net/file_images/article/201702/2017020616015448.png)

可以看出，通过转换为字符串的速度是最慢的。Seralizable次之，Parcelable比Seralizable快10倍。所以从性能上考 虑，我们必定优先选择Parcelable。但是Parcelable有大量重复的模板代码，如何简化这些操作，将是下面主要讲解的内容。

**5.简化Parcel操作**

如果你使用android Studio 可以通过安装android-parcelable-intellij-plugin插件，或者自己配置模板进行操作。

**5.1 parceler**

除了上面的操作，还有大量的第三方库来简化Parcelable操作。当然使用这些库也许会降低Parcelable的性能。Parceler就是这样一个库。

Parceler使用非常简单，在定义Model时用@Parcel进行注解，在传递数据的时候使用Parcels的wrap方法来包装成一个Parcelable对象。获取数据时用Parcels的unwrap方法来获取对象。

```java
public class Author { 
  
  int id; 
  
  String name; 
  
  //setter & getter... 
}
```

```java

```

**传递对象**

```java
Book book=new Book(); 
book.setTitle("Java编程思想"); 
Author author=new Author(); 
author.setId(1); 
author.setName("Bruce Eckel"); 
book.setAuthor(author); 
Intent intent=new Intent(this,SecondActivity.class); 
intent.putExtra("book", Parcels.wrap(book)); 
startActivity(intent);
```

**接收对象**

```java
Book book= Parcels.unwrap(getIntent().getParcelableExtra("book")); 
Log.d(TAG,"book title->"+book.getTitle()); 
Log.d(TAG,"book author name->"+book.getAuthor().getName());
```

除了Parceler之外，还有如auto-parcel,ParcelableCodeGenerator,ParcelableGenerator等第三方库，这里我将不进行讲解，有兴趣的朋友，可以自行研究。

---

在应用中，可能会在当跳转到另外一个Activity的时候需要传递数据过去，这时就可能用Bundle对象；

在MainActivity中，有一个导航至BActivity的Intent，

Intent

```java

　　Intent intent = new Intent(Context context, Class<?> class);
　　//new一个Bundle对象,并将要传递的数据导入,Bunde相当于Map<Key,Value>结构   
　　Bundle bundle = new Bundle();
　　bundle.putString("name","Livingstone");
　　bundle.putXXX(XXXKey, XXXValue);
　　//将Bundle对象添加给Intent
　　intent.putExtras(bundle);
　　//调用intent对应的Activity
　　startActivity(intent);
}
```

在BActivity中，通过以下代码获取MainActivity所传过来的数据　

```java
Bundle bundle = this.getIntent().getExtras();// 获取传递过来的封装了数据的Bundle

　　String name = bundle.getString("name");// 获取name_Key对应的Value

　　// 添加什么类型的值就获取什么类型的

     --> bundle.getXXX(XXXKey);

　　　　　　 return XXXValue
```

上面讲述的都是一般的基本数据类型，当需要传递对象的时候，可以使该对象实现Parcelable或者是Serializable接口；

通过Bundle.putParcelable(Key,Obj)及Bundle.putSerializable(Key,Obj)方法将对象添加到Bundle中，再将此Bundle对象添加到Intent中！在跳转的目标页面通过Intent.getSerializableExtra(Key)获取实现了Serializable的对象；

今天在研究的时候发现，Intent.putExtra(Key,Value)；其实也可以传递数据，包括上面所讲的对象！

实现Serializable接口很简单，不再描述；

```java
public class Book implements Parcelable {
 private String bookName;
 private String author;

 public static final Parcelable.Creator CREATOR = new Creator() {// 此处必须定义一个CREATOR成员变量，要不然会报错！

  @Override
  public Book createFromParcel(Parcel source) {// 从Parcel中获取数据，在获取数据的时候需要通过此方法获取对象实例
   Book book = new Book();
   book.setAuthor(source.readString());// 从Parcel读取数据，读取数据与写入数据的顺序一致！
   book.setBookName(source.readString());
   return book;
  }

  @Override
  public Book[] newArray(int size) {
   return new Book[size];
  }
 };

 @Override
 public int describeContents() {
  return 0;
 }

 @Override// 写入Parcel
 public void writeToParcel(Parcel dest, int flags) {
  dest.writeString(author);// 将数据写入Parcel，写入数据与读取数据的顺序一样！
  dest.writeString(bookName);
 }
}
```

关于Parcel，大概查阅了一下描述:

 一个final类，用于写或读各种数据，所有的方法不过就是writeValue(Object)和read(ClassLoader)！(个人翻译理解)
