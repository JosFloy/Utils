# 录音权限

### 6.0之前的权限检测只是检测到是否在清单文件中注册

```java
Boolean flag = (PackageManager.PERMISSION_GRANTED ==
pm.checkPermission("android.permission.RECORD_AUDIO", "包名"));
Boolean flag = PermissionChecker.checkSelfPermission(this, Manifest.permission.)== PermissionChecker.PERMISSION_GRANTED;
if (flag){
  ToastUtil.showMessage("有权限");
} else {
  ToastUtil.showMessage("无权限");
  return;
}
```

在6.0系统一下 无论是关闭或者打开app的录音权限都能获取到权限，6.0以上则正常，后来发现是6.0以后google加强了权限管理

```java
public class CheckPermissionUtils {
  /**
  *获取app的录音权限是否打开
  *android 6.0version以上 传统方法不适合 以此兼容
  * @param context
  */
  public static Boolean isHasAudioRecordPermission(Context context) {
    // 音频获取源
    int audioSource = MediaRecorder.AudioSource.MIC;
    // 设置音频采样率，44100是目前的标准，但是某些设备仍然支持22050，16000，11025
    int sampleRateInHz = 44100;
    // 设置音频的录制的声道CHANNEL_IN_STEREO为双声道，CHANNEL_CONFIGURATION_MONO为单声道
    int channelConfig = AudioFormat.CHANNEL_IN_STEREO;
    // 音频数据格式:PCM 16位每个样本。保证设备支持。PCM 8位每个样本。不一定能得到设备支持。
    int audioFormat = AudioFormat.ENCODING_PCM_16BIT;
    // 缓冲区字节大小
    int bufferSizeInBytes = 0;
    bufferSizeInBytes = AudioRecord.getMinBufferSize(sampleRateInHz,
            channelConfig, audioFormat);
    AudioRecord audioRecord = new AudioRecord(audioSource, sampleRateInHz,
            channelConfig, audioFormat, bufferSizeInBytes);
    //开始录制音频
    try{
      // 防止某些手机崩溃，例如联想
      audioRecord.startRecording();
    }
    catch (IllegalStateException e){
      e.printStackTrace();
    }
    /**
     * 根据开始录音判断是否有录音权限
     */
    if (audioRecord.getRecordingState() != AudioRecord.RECORDSTATE_RECORDING) {
      return false;
    }
    audioRecord.stop();
    audioRecord.release();
    audioRecord = null;
    return true;
  }
}
```

最后一种，测试没问题

```java
public class CheckPermissionUtils {
  private static final String TAG = "CheckPermissionUtils";
  private static CheckPermissionUtils checkPermissionUtils = new CheckPermissionUtils();
  static final int SAMPLE_RATE_IN_HZ = 44100;
  static final int BUFFER_SIZE = AudioRecord.getMinBufferSize(
  SAMPLE_RATE_IN_HZ, AudioFormat.CHANNEL_IN_DEFAULT,
  AudioFormat.ENCODING_PCM_16BIT);
  private AudioRecord mAudioRecord;
  Boolean isGetVoiceRun;
  private Object mLock;
  private int count=0;
  private Boolean isHasPermission;
  private CheckPermissionUtils() {
    mLock = new Object();
  }
  public static CheckPermissionUtils getinstance() {
    if (checkPermissionUtils == null) {
      checkPermissionUtils = new CheckPermissionUtils();
    }
    return checkPermissionUtils;
  }
  public Boolean isHasAudioRecordingPermission(Context context) {
    isHasPermission=false;
    count=0;
    mAudioRecord = new AudioRecord(MediaRecorder.AudioSource.MIC,
            SAMPLE_RATE_IN_HZ, AudioFormat.CHANNEL_IN_DEFAULT,
            AudioFormat.ENCODING_PCM_16BIT, BUFFER_SIZE);
    if (mAudioRecord == null) {
      Log.e("sound", "mAudioRecord初始化失败");
    }
    isGetVoiceRun = true;
    try {
      //    new Thread(new Runnable() {
      //      @Override
      //      public void run() {
      mAudioRecord.startRecording();
      short[] buffer = new short[BUFFER_SIZE];
      while (isGetVoiceRun) {
        count++;
        if (count++>10) {
          isGetVoiceRun=false;
        }
        //r是实际读取的数据长度，一般而言r会小于buffersize
        int r = mAudioRecord.read(buffer, 0, BUFFER_SIZE);
        long v = 0;
        // 将 buffer 内容取出，进行平方和运算
        for (int i = 0; i < buffer.length; i++) {
          v += buffer[i] * buffer[i];
        }
        // 平方和除以数据总长度，得到音量大小。
        double mean = v / (double) r;
        double volume = 10 * Math.log10(mean);
        Log.d(TAG, "-------分贝值:" +volume+"----v"+v+"------r"+r );
        if (v>0&&r>0) {
          //有录音
          isHasPermission=true;
          return isHasPermission;
        }
        // 大概一秒十次
        synchronized (mLock) {
          try {
            mLock.wait(5);
          }
          catch (InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
      mAudioRecord.stop();
      mAudioRecord.release();
      mAudioRecord = null;
      //  }
      //}).start();
    }
    catch (Exception e) {
    }
    return isHasPermission;
  }
}
```