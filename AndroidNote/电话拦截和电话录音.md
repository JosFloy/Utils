# 电话拦截和电话录音

## 一、问题描述

使用BordercastReceiver和Service组件实现下述功能：

-[ ] 当手机处于来电状态，启动监听服务，对来电进行监听录音


-[ ] 设置电话黑名单，当来电是黑名单电话，则直接挂断

当拨打电话或电话状态发生改变时，系统就会发出有序广播，因此我们可以使用BordercastReceiver接受广播，因**BordercastReceiver执行时间短不能执行耗时任务也不能使用子线程**，因此我们应启动一个Service来监听电话并进行处理

## 二、加入AIDL文件

Android没有对外公开结束通话的API,要结束通话就必须使用AIDL与电话管理服务进行通信,并调用服务中的API实现结束通话,这样需要android 源码文件NeighboringCellInfo.aidl和ITelephony.aidl添加到项目中，如图所示：

 ![201510220909291](D:\我的文档\My Pictures\201510220909291.png)

<u>Android Studio 会自动编译产生对应的类文件</u>

## 三、编写TelReceiver组件

```java
public class TelReceiver extends BroadcastReceiver {
 public TelReceiver() {
 }
 
 @Override
   public void onReceive(Context context, Intent intent) {
   Intent i=new Intent(context,ListenPhoneService.class);
   i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
   i.setAction(intent.getAction());
   i.putExtra(TelephonyManager.EXTRA_INCOMING_NUMBER,
    intent.getStringExtra(TelephonyManager.EXTRA_INCOMING_NUMBER));//电话号码
   i.putExtra(TelephonyManager.EXTRA_STATE,
    intent.getStringExtra(TelephonyManager.EXTRA_STATE));//电话状态
   context.startService(i);//启动服务
   }
}
```

***注册广播：***

```java
<receiver android:name=".TelReceiver">
  <intent-filter android:priority="1000">
    <action android:name="android.intent.action.PHONE_STATE"/>
 	<action andorid:name="androird.intent.action.NEW_OUTGOING_CALL"/>
  </intent-filter>
</receiver>
```

## 四、编写ListenPhoneService组件

```java
public class ListenPhoneService extends Service {
 private AudioManager mAudioManager;
 private TelephonyManager tm;
 public ListenPhoneService() {
 }
 @Override
 public void onCreate() {
 super.onCreate();
 mAudioManager=(AudioManager)getSystemService(Context.AUDIO_SERVICE);
 tm=(TelephonyManager)getSystemService(Service.TELEPHONY_SERVICE);
 }
 @Override
 public int onStartCommand(Intent intent, int flags, int startId) {
 if(intent.getAction().equals(Intent.ACTION_NEW_OUTGOING_CALL)){//去电广播，android没有来电话广播
 }else{//去掉拨打电话就是来电状态了
 //方法1
//获得来电电话
// String number=intent.getStringExtra(TelephonyManager.EXTRA_INCOMING_NUMBER);
//获得电话状态
// String state=intent.getStringExtra(TelephonyManager.EXTRA_STATE);
//  Log.d("jereh", "incoming phone:" + number);
//  Log.d("jereh","call state:"+state);
//  TelephonyManager.EXTRA_STATE_IDLE: 没有来电 或者 挂断
//  TelephonyManagerEXTRA_STATE_OFFHOOK: 接起电话
//  TelephonyManager.EXTRA_STATE_RINGING:当电话呼入时,响铃时
//  if(state.equals(TelephonyManager.EXTRA_STATE_RINGING)){
//  if(number.equals("13280998858")){//拦截指定的电话号码
//  mAudioManager.setRingerMode(AudioManager.RINGER_MODE_SILENT);
//  Log.d("jereh","电话被拦截");
//  stopCall();
//   mAudioManager.setRingerMode(AudioManager.RINGER_MODE_NORMAL);//恢复铃声
//  }
//  }else if(state.equals(TelephonyManager.EXTRA_STATE_OFFHOOK)){
 //接起电话
//  recordCall();//开始录音
//  }else if(state.equals(TelephonyManager.EXTRA_STATE_IDLE)){
//  stopCall();//停止录音
//  }
 //方法2
  // 设置一个监听器,监听电话状态
  tm.listen(listener,PhoneStateListener.LISTEN_CALL_STATE);
 }
 return super.onStartCommand(intent, flags, startId);
 }
 /**
 * 挂断电话
 */
 private void stopCall(){
 try {
  //Android的设计将ServiceManager隐藏了，所以只能使用反射机制获得。
  Method method=Class.forName("android.os.ServiceManager").getMethod("getService", String.class);
  IBinder binder=(IBinder)method.invoke(null, new Object[]{"phone"});//获得系统电话服务
  ITelephony telephoney=ITelephony.Stub.asInterface(binder);
  telephoney.endCall();//挂断电话
  stopSelf();//停止服务
 } catch (Exception e) {
  e.printStackTrace();
 }
 }
 PhoneStateListener listener=new PhoneStateListener(){
 @Override
 public void onCallStateChanged(int state,String incomingNumber){
  switch (state){
  //手机空闲了
  case TelephonyManager.CALL_STATE_IDLE:
   stopCall();//停止录音
   break;
  //接起电话
  case TelephonyManager.CALL_STATE_OFFHOOK:
   recordCall();//开始录音
   break;
  // 响铃时
  case TelephonyManager.CALL_STATE_RINGING:
   Log.e("jereh", "来电号码是："+ incomingNumber);
   // 如果该号码属于黑名单
   if (incomingNumber.equals("123456")) {
   // 如果是黑名单，就进行屏蔽
   stopCall();
   }
   break;
  }
 }
 };
 /**
 * 停止录音
 */
 private void stopRecord(){
 if(recording){
  recorder.stop();
  recorder.release();
  recording=false;
  stopSelf();//停止服务
 }
 }
 /**
 * 电话录音
 */
 private MediaRecorder recorder;
 private boolean recording ;
 private void recordCall(){
 Log.d("jereh", "record calling")
 if( Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)){
 recorder=new MediaRecorder();
 recorder.setAudioSource(MediaRecorder.AudioSource.MIC);//读麦克风的声音
 recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);//设置输出格式
 recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);// 编码方式
 File file=new File(Environment.getDownloadCacheDirectory().getAbsolutePath(),"recorder");
 if(!file.exists()){
  file.mkdir();
 }
 recorder.setOutputFile(file.getAbsolutePath() + "/"
 + System.currentTimeMillis() + "3gp");// 存放的位置是放在sd卡recorder目录下
 try {
  recorder.prepare();
  recorder.start();
  recording=true;
 } catch (IOException e) {
  e.printStackTrace();
 }
 }
 }
 @Override
 public IBinder onBind(Intent intent) {
  throw new UnsupportedOperationException("Not yet implemented");
 }
}
```

Service XML配置

```java
<service
  android:name=".ListenPhoneService"
  android:enabled="true"
  android:exported="true">
</service>
```

## 五、最后别忘记申请权限

```java
<!-- 添加访问手机电话状态的权限 -->
<uses-permission android:name="android.permission.READ_PHONE_STATE" />
<!-- 拨打电话权限 -->
<uses-permission android:name="android.permission.CALL_PHONE" />
<!-- 监听手机去电的权限 -->
<uses-permission android:name="android.permission.PROCESS_OUTGOING_CALLS" />
<!-- 在SDCard中创建与删除文件权限 -->
<uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS" />
<!-- 往SDCard写入数据权限 -->
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
```