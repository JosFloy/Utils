# Framework构建

## 1、避免选择应用组件搭建架构

应用组件（Activities, Services, Providers, Receivers)是你与操作系统交互的接口但是不要将它们看作是搭建整个应用架构的基础工具。每一个组件在系统中有自己特定语境，通常也只应该有需要的时候才使用：

- **Activity** 应用顶级的UI实体。它相当于传统操作系统中的main函数 （当用户点击应用icon的时候运行）。当你希望其它应用启动你应用的特定部分的时候才应该使用Activity来实现它。比如执行一个分享的操作或者打开应用中的一些内容时。如果你只是从自己的应用中去获取一个UI的时候，没有必要通过Activity来实现它，你也可以只转变当前UI的状态（比如通过fragments）。在fragments出现之前一个应用的架构可能通过多个activities来实现是比较常见的，但是现在已经是不必要的了，除非你需要特定的设计。
- **Service**  一个用于在Activity UI 之外执行一个长时间的操作的服务。它可以自启动（通过Context.startService()）或者运行在另一个进程中（Context.bindService()），如果这些行为你都不需要，那么你就不应该使用Service。

比如你需要后台工作但是不需要自启动（下载UI需要的内容，可以在用户重新回到UI的时候resume），你应该使用本地线程的原始类，比如： AsyncTask, Loader, HandlerThread, 等等。service是资源敏感的（需要作为全局状态的一部分被一直追踪），而且当你的应用不需要service的时候它还在后台运行，可能导致一些 bug（这是Android中常见的问题，而且对系统是有害的）。如果你需要将同一进程的代码关联起来，不要使用bindSerice()，使用简单的 callbacks和其它工具就可以。因为它们更容易编码也更容易理解，并且资源耗费更少。当然你要理解AsyncTask的异步特性，当 Activity finish掉之后结果才返回的情况也是有可能的。在使用结果时请check Activity的状态。

-Broadcast Receiver 关注感兴趣的特定事件，在事件发生的时候会自动唤起 。

## Services要么被绑定要么自启动

Service要么是作为一个被绑定的服务，要么是一个自发起的服务，避免两者同时出现。

如果有必要，一个绑定的service为了继续在后台执行可以自启动，但是当工作完成的时候也要finish掉自己。（额外的start-service产生的冲突可能会导致一些错误）

## 独立的事件优先选择Broadcast而不是Service

使用broadcasts去分发独立的事件，使用service处理那些生命周期较长的事件。

## 避免通过Binder传递大对象

为了通过Binder进行序列化，对象需要被复制，因此对象越大，传递过程的处理时间就越长。

## 将UI处理从后台service中区分开来

当系统资源受限的时候activity manager会将activities干掉。如果你的activity与后台的任务绑定的太近，那么其中一者挂掉，另外一者也同样不可用了。一个好的例子是music 应用将UI和播放内容的service分离开来，UI activity可能被干掉，但不会引起后台service继续音乐的播放。

## 避免文件路径的硬编码

尽量从上context或者Environment中获取

- 不要硬编码全局的路径”/sdcard”，使用Environment.getExternalStorageDirectory() 或者相关的方法替代
- 不要硬编码应用路径： “/data/data/myapp/databases”, 使用 Context.getDatabasePath(), Context.getFilesDir()或者相关的方法替代

## 只持久化相对路径

当你需要持久化某个路径的时候，为了防止路径的变化，你应该使用相对路径。比如你的应用的备份需要恢复到一个新的设备上，数据路径就可能有些不同。

比如通过Context.getFilesDir() 方法返回的路径在不同的设备，用户或者配置时发生变化。因此在运行期间只通过相对路径构造绝对路径是最安全的。

避免过重的标准化以免出现特定的安全情况。

## 对临时文件使用缓存存储

通过Context.getCacheDir(). 返回的缓存目录将应用的临时文件从其它的持久化数据中分离出来。下面是更高效的存储的建议：

- 缓存目录的文件在内存不足的情况下可能会被系统删除掉，不像在data目录下的文件只有在应用被卸载或者用户明确请求清除应用数据的时候才会被删除。
- cache目录的文件从来不会被备份，不像data目录下的文件可能会自动备份

## 简单的需求避免使用SQLite

SQLite是一个完全的关系型数据引擎，对于不需要维护关系的简单的数据结构或者key/value 键值对来说是过度的使用。事务的完整性在每次I/O操作中很重要，但是如果你不需要它们，就会让你的应用更慢。

如果你的数据很简单，考虑以下替换：

- 简单的key values 使用SharedPreferences存储。首先它们在第一次读取之后会被静态的缓存。这样加速了访问速度，但是如果你使用过于复杂可能导致泄漏和内存的问题。第二，commit的变化会导致整个SharedPreferences结构的重写，因此小而频繁的更新所做的工作可能会比期望的更多。
- 当需要存储一些时序事件的数据时，使用只会在尾部添加的log文件，并定时处理它
- 如果你需要的只是NoSQL，并且能够正确的，最小化的使用JNI，你可以使用[LevelDB](https://github.com/google/leveldb)

## 避免使用太多的数据库

SQLite数据库在硬盘和内存中都是比较耗资源的。不要为每一个表单独创建一个独立的DB。大多数应用应该只有一个DB。

## 让用户选择内容的存储位置

设备通常有多个存储位置，包括多个SDCard，USB驱动以及云存储。通过[Storage Access Framework](http://www.devtf.cn/?p=639)让用户去选择打开或者存储数据的位置.

可以启动简单的intents去提示用户打开或者保存一个文件，接收一个content:// UIR准备数据存储。当需要一个传统样式的文件API时，[DocumentFile](https://developer.android.com/reference/android/support/v4/provider/DocumentFile.html)support library类可以更容易的适应现有的代码。

